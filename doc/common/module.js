// Модульная область видимости
// Это область видимости, создаваемая модулем. Модуль — это JS-файл (или тег <script>), 
// написанный и подключаемый по особым правилам.
//  О модулях мы ещё поговорим отдельно. Пока достаточно знать, что обычный 
//  JS-код становится модульным, если при подключении указать атрибут type="module".

// Ещё раз, если скрипт подключён как модуль, то все переменные и функции, 
// объявленные в этом модуле, в глобальную область видимости не попадают. 
// При этом переменные из глобальной области видимости модулю доступны.

// В область видимости модуля попадают переменные и функции, объявленные
//  «прямо в JS-модуле» (или в теге <script>-модуле). Возьмём ранее рассмотренный пример и немного его изменим:

//  Затенение переменных
// Когда браузер читает JavaScript-код и встречает переменную, он ищет её объявление снизу вверх.
//  То есть сперва в той области, где встретил переменную, а потом вверх по иерархии. 
//  FЕсли вплоть до глобальной области видимости переменная будет не найдена, то выполнение прервётся ошибкой ReferenceError:

 function log () {
    if (2 > 1) {
      console.log(mascot);
    }
  }
  
  // log(); // ReferenceError: mascot is not defined
  // Чтобы вывести в консоль переменную mascot, JavaScript сперва поищет её в блоке кода if, затем в блоке функции log(), после в модульной области видимости (если файл — модуль) и в конце концов в глобальной области видимости, где тоже переменную не найдёт. Тут и случится ошибка.
  
  // Благодаря такому механизму поиска в областях разного уровня вложенности можно использовать переменные с одним и тем же именем:
  
  function log () {
    const mascot = 'Кекс';
    console.log(mascot); // "Кекс"
  
    if (2 > 1) {
      const mascot = 'Борис';
      console.log(mascot); // "Борис"
    }
  }
  
  log();

//   Модуль должен описывать и давать понимание, какие у него есть зависимости. 
// Например, модуль может зависеть от других модулей.

// Файл сain.js
import {name} from './mother.js';

`My mother is ${name}`; // My mother is Eve
// Модуль сain.js зависит от модуля mother.js, а конкретно от переменной name,
//  полученной из этого модуля.

// Про синтаксис import и export сейчас нужно знать лишь то, что они есть, 
// что import — это импорт, а export — экспорт в прямых своих значениях. О всех остальных нюансах мы поговорим далее.

// Модуль должен описывать интерфейс — методы и свойства — которые он может предоставить другим модулям. Чтобы предыдущий пример работал, нам нужно показать, что у модуля mother.js в интерфейсе есть свойство name, которое могут использовать другие модули.

// Файл mother.js
const name = 'Eve';

export {name};

// Файл mother.js
const motherName = 'Eve';

export {motherName};
// Файл father.js
const fatherName = 'Adam';

export {fatherName};
// Файл сain.js
import {motherName} from './mother.js';
import {fatherName} from './father.js';

`My mother is ${motherName}`; // My mother is Eve
`My father is ${fatherName}`; // My father is Adam
// Чтобы браузер считал JS-файл модулем, его нужно подключить как модуль:

<script type="module" src="сain.js"></script>

// В противном случае модульные конструкции вроде import и export ничего кроме ошибки не вызовут.

// Просто импорт
// Когда нам нужно только выполнить код модуля, достаточно его просто импортировать:

// Файл alert.js
alert('Hello, world!');
// Файл index.js
import './alert.js';

// Именованные экспорт и импорт
// Обратите внимание, экспорт и импорт похожи на деструктуризацию, но только похожи.

// Всё просто, в одном модуле мы явно говорим, что хотим экспортировать:

// Файл mother.js
const name = 'Eve';
const age = 18;

export const sex = 'female'; // Экспорт сразу при объявлении

export {name, age}; // Экспорт уже объявленных переменных
// А в другом явно это импортируем:

// Файл сain.js
import {name} from './mother.js';

`My mother is ${name}`; // My mother is Eve
// Имена переменных должны совпадать полностью. Если запрашиваемой переменной нет среди экспортируемых, то будет ошибка, и модуль не загрузится. Импортировать всё, что экспортирует модуль, необязательно, поэтому мы ограничились только переменной name, а могли бы импортировать всё:

import {sex, name, age} from './mother.js';
// Экспортировать одну и ту же переменную дважды нельзя:

// Файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`;

export {sex};

// Импорт — не объявление
// Важно помнить, что импорт переменной не то же самое, что её объявление. При импорте переменная не создаётся, а честно импортируется, самая настоящая переменная из другого модуля. Такое поведение справедливо для всех видов импорта, которые мы разберём дальше (экспортировать как-то иначе тоже нельзя), поэтому будьте внимательны при работе с импортированными переменными. Ведь сложные типы данных, вроде объектов или массивов, при импорте передаются по ссылке, и их можно нечаянно испортить:

// Файл items.js
const items = ['one', 'two', 'three'];

export {items};
// Файл reverse.js
import {items} from './items.js';

items.reverse(); // Испортили массив в модуле items.js, хотя переворачиваем его в reverse.js

// Поэтому не забывайте про Object.assign() и Array.prototype.slice() и им подобные методы, когда работаете с импортированной структурой:

// Файл items.js
const items = ['one', 'two', 'three'];

export {items};
// Файл reverse.js
import {items} from './items.js';

items.slice().reverse(); // Перевернули копию, исходный массив в items.js остался цел

// С примитивами тоже не всё так просто. Даже если импортируете let-переменную, по спецификации движок JavaScript не позволит вам изменить её. Она считается read-only переменной (доступной только для чтения):

// Файл mother.js
let name = 'Eve';

export {name};
// Файл сain.js
import {name} from './mother.js';

name = 'Adam'; // Ничего не выйдет, кроме ошибки
// Поэтому распространённой практикой является экспорт только const-значений и им подобных (классов, например). На курсе мы тоже будем экспортировать только const-переменные или class.

// Экспорт по умолчанию
// Синтаксически экспорт по умолчанию отличается вводом дополнительного ключевого слова default:

// Файл mother.js
const mother = {
  name: 'Eve',
  age: 18,
  sex: 'female',
};

export default mother;
// Фигурные скобки не нужны, поскольку экспортировать по умолчанию можно лишь одну переменную.

// Главное отличие такого экспорта от именованного — возможность экспортировать значение напрямую, без переменной:

// Файл mother.js
export default {
  name: 'Eve',
  age: 18,
  sex: 'female',
};
// Из-за этого отличается и импорт такого значения «по умолчанию». Раз у нас нет переменной, то под каким именем импортировать? Под любым!

// import father from './mother.js';
// В этом заключается и главная особенность, и главная проблема экспорта по умолчанию — мы можем задать любое имя при импорте. Такое поведение усложняет отладку и навигацию по коду, поэтому мы не рекомендуем использовать экспорт по умолчанию.

// Нюансы
// Код модуля выполняется целиком
// Независимо от того, импортирован ли просто модуль import './alert.js' или какие-то конкретные переменные из модуля import {name} from './mother.js', браузер выполнит код всего модуля. Другими словами, если модуль импортирован, его код будет выполнен целиком независимо от способа импорта.

// Только первый уровень
// import и export не могут быть вложены в функции или другие блоки кода:

// Файл сain.js
if (true) {
  // Так нельзя
  import {motherName} from './mother.js';
}

const name = `сain`;

(() => {
  // Так тоже нельзя
  export { name };
})();


// Никакого поднятия (hoisting)
// Импортированные переменные не поднимаются, поэтому import всегда должен быть в начале файла:

const message = `My mother is ${motherName}`;

// Так нельзя, браузер выдаст ошибку
import {motherName} from './mother.js';

// объект math namespace или пространство имен.

// 1.Один модуль одна задача. 
// 2. В одном модуле должен быть смысл. Например валидация всех форм.
// 3. библиотека будет передаваться из одного проекта в другой


import './dialog.js';
import './setup.js';
import {createElement} from './create-element.js';

createElement();


// именуем кебаб-кейс

// дуе становится read only 

// export только const переменных. 
// если экспортировать объекты то данные объектов меняются в обоих файлах.

// в импортируемом файле нельзя переписать let переменную

// желательно экспортировать только функции


// В одной из прошлых статей мы выяснили, что ни импорт, ни экспорт не могут быть вложены в другие блоки кода, и что импорт всегда должен быть вверху модуля.

// Теперь давайте рассмотрим, как import загружает скрипт по URL. Путь может быть указан как в одинарных:

import mother from './mother.js';
// Так и в двойных кавычках:

import mother from "./mother.js";
// Путь может быть абсолютным или относительным. Поддерживаются:

import 'https://jakearchibald.com/utils/bar.js'; // URL
import '/utils/bar.js'; // Абсолютный путь относительно домена
import './bar.js'; // Относительный путь от текущего модуля
import '../bar.js'; // Относительный путь от родительской директории
// Не поддерживаются:

import 'bar.js';
import 'utils/bar.js';
// «Не поддерживаются» в данном случае значит, что «синтаксис зарезервирован». На самом деле такой импорт используется для подключения сторонних библиотек из пакетных менеджеров вроде npm и не является частью стандарта ECMAScript.