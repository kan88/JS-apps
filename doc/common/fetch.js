// Fetch API — современный, гибкий и универсальный способ для отправки запросов к серверу. Мы говорим Fetch API, но по факту подразумеваем функцию fetch(), с помощью которой можно получать и отправлять произвольные данные на сервер.

// А что было до fetch()?
// Для отправки запросов к серверу браузеры долгое время предоставляли лишь один способ — объект XMLHttpRequest. В своё время Microsoft сделала прорыв с этой технологией, и позже XMLHttpRequest был стандартизирован WHATWG.

// С тех пор прошло много времени, и требования к этой, на первый взгляд, несложной задаче изменились. Объектом XMLHttpRequest пользоваться стало неудобно. Отсутствие поддержки промисов, не совсем очевидный интерфейс и так далее. Это не говорит о том, что XMLHttpRequest работает плохо и не годится для взаимодействия с сервером. Вовсе нет. Это по-прежнему рабочий инструмент, но сегодня браузеры предлагают новое, улучшенное API для выполнения запросов — Fetch API.

// Синтаксис
// Начнём знакомство с fetch() с рассмотрения интерфейса. Функция принимает два параметра: адрес ресурса, на который требуется отправить запрос, и объект с настройками. Второй параметр опционален и может не использоваться:

// fetch(адрес[, настройки]);
// Результатом выполнения fetch() станет промис. За счёт поддержки промисов, обрабатывать результат выполнения fetch() становится гораздо удобней. Попробуем проверить на реальном примере. Запросим информацию о публикациях у тестового сервера JSONPlaceholder с помощью fetch():

// fetch('https://jsonplaceholder.typicode.com/posts')
//   .then((response) => response.json())
//   .then((posts) => console.log(posts));
// Этот простой пример демонстрирует выполнение GET-запроса для получения данных (список публикаций) в JSON. Первым аргументом fetch() мы передали адрес ресурса. Второй аргумент не задали, так как для выполнения GET-запроса дополнительные настройки не требуются. По умолчанию fetch() выполнит именно GET-запрос.

// Раз fetch() возвращает промис, мы получаем возможность использовать знакомые методы then, catch и finally. В случае успешного завершения промиса мы получим от сервера объект с ответом. Само собой не в текстовом виде, а в структурированном. Объект позволит понять состояние ответа и получить не только данные из тела ответа, но и при необходимости служебную информацию. Например, заголовки, установленные сервером.

// Ещё раз,fetch() не привносит магии — взаимодействие с сервером по-прежнему происходит в асинхронном режиме. Это означает, что запрос выполнится не мгновенно, а данные мы получим не сразу. Результатом выполнения fetch() будет промис в состоянии выполняется.

// В представленном примере нас интересуют только данные. Результат выполнения fetch() — ответ от сервера — попадёт в параметр response(это специальный объект ответа, о нём будет дальше). Нам заранее известно, что сервер вернёт информацию о публикациях в JSON. Поэтому мы не делаем дополнительных проверок, а сразу пытаемся прочитать JSON, для этого используем метод json() у объекта с ответом:

// .then((response) => response.json())
// Встроенный метод json() автоматически извлечёт JSON-данные из ответа, преобразует их в объект или массив, чтобы с данными можно было работать в JavaScript, и вернёт новый промис. А раз результатом станет промис, то можно продолжать цепочку then и вывести данные в консоль:

// .then((posts) => console.log(posts));
// Попробуйте скопировать код целикового примера и выполнить на этой странице в консоли браузера. Спустя какое-то время в консоли появится список публикаций.

// Рисунок 1. Результат выполнения fetch
// Рисунок 1. Результат выполнения fetch
// Объект ответа (Response)
// Объект ответа (Response) мы получаем при завершении промиса. В этом объекте хранится вся информация об ответе сервера: заголовки, статусы, результат выполнения запроса и другая служебная информация.

// Объект ответа — не всегда данные
// Сервер может исполнить не все запросы. Самая банальная ситуация: запрашиваемый ресурс не найден. Это может случиться по разным причинам: ресурс был, но потом его перенесли в другое место или в адресе была допущена ошибка. На такой запрос сервер ответит кодом 404.

// Возникает вопрос: «А как понять статус выполнения запроса?» Ведь если сервер вернул 404, то нет никакого смысла пытаться извлечь JSON. Данных ведь нет. При этом промис не будет завершён с ошибкой, ведь сервер ответил, а значит перехватить такую ситуацию с помощью catch не получится.

// Определить успешность выполнения запроса поможет свойство объекта ответа ok. Оно содержит булево значение. Если запрос выполнен успешно, ok будет true. В противном случае false.

// Звучит не сложно, но возникает другой вопрос: «А что подразумевается под успехом выполнения?» Успех определяется на основании кода ответа сервера на запрос. Если код ответа в диапазоне чисел 200-299, значит он выполнился успешно. Ответы с кодами, которые не попадают в диапазон, означают выполнение запроса с ошибкой.

// Немного доработаем пример получения списка публикаций. Добавим в него проверку успешности выполнения запроса:

// // Для проверки обработки ошибки изменим часть адреса,
// заведомо указав несуществующий адрес /posts1
fetch('https://jsonplaceholder.typicode.com/posts1')
  .then((response) => {
    if (response.ok) {
      return response;
    }

    throw new Error(`${response.status} — ${response.statusText}`);
  })
  .then((response) => response.json())
  .then((posts) => console.log(posts))
  .catch((error) => console.log(error));
// Код примера немного подрос, но мы не потеряли в читабельности. В первом then выполняется проверка свойства ok. Если оно равно true, значит серверу есть, чем ответить. Можно возвращать объект ответа и продолжать конвейер обработки (обработать JSON и так далее).

// Если значение ok равно false, серверу нечем ответить, разумным решением в такой ситуации станет формирование объекта с ошибкой. Для этого бросим исключение с Error. Аргументами передадим значения свойств объекта ответа status (код ответа сервера) и statusText (пояснительная строка).

// Как только будет брошено исключение, оно переведёт промис в состояние завершён с ошибкой, и мы сможем перехватить его в catch, чтобы вывести в консоль содержимое ошибки.

// Рисунок 2. Обработка ошибки
// Рисунок 2. Обработка ошибки
// А что с другими ошибками?
// Если ошибку вернул не сервер, а, например, в момент запроса пропал интернет, в такой ситуации промис, возвращаемый fetch(), будет завершён с ошибкой. Следовательно, обработать такую ситуацию можно в методе catch. Поэтому не забывайте добавлять его в конце цепочки then!

// Отправка информации на сервер
// Работа с fetch() не ограничивается лишь получением данных от сервера. Ничего не мешает их передавать на сервер. Эта задача не сильно сложней, но придётся задействовать второй аргумент fetch() — объект с настройками.

// Попробуем подготовить и отправить запрос методом POST (речь о методе в контексте протокола HTTP):

// Данные для отправки
const post = {
  id: 1,
  userId: 31337,
  title: 'Fetch API',
  body: 'Fetch API — современный, гибкий и универсальный способ для отправки запросов к серверу...',
};

// Вторым аргументом передадим объект с настройками.
// Определим в нём метод, заголовки и тело запроса
fetch(
  'https://jsonplaceholder.typicode.com/posts',
  {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(post),
  })
  .then((response) => response.json())
  .then((json) => console.log(json));
// Рисунок 4. Результат отправки данных методом POST
// Рисунок 4. Результат отправки данных методом POST
// В этом примере кода задействован второй аргумент fetch(). С его помощью мы передаём объект с настройками, где переопределяем HTTP-метод (по умолчанию GET, а нам нужен POST).

// При подготовке запроса нам доступна возможность установить произвольные заголовки. Для этого в объекте с настройками предусмотрено свойство headers. Это обычный объект, где каждая пара ключ-значение описывает заголовок. В приведённом примере определяем один заголовок — Content-Type (тип содержимого). Данные передаются в формате JSON, ему соответствует тип application/json. Другие заголовки добавляются аналогичным образом. Например, если потребуется добавить заголовок User-Agent, то достаточно описать ещё одну пару ключ-значение:

headers: {
  'Content-Type': 'application/json',
  'User-Agent': 'Google Chrome'
},
// Тело запроса фиксируется в свойстве body. Мы планируем отправить данные в JSON, поэтому сразу превращаем подготовленный объект с данными в JSON с помощью JSON.stringify(). Дальше всё повторяется: пишем код для обработки ответа, возможной ошибки и т. д.

// Резюме
// fetch() — это современный способ отправки запросов с клиента к серверу. В простых случаях можно обойтись буквально одной строчкой кода, а за счёт поддержки промисов обработка ответов также упрощается и превращается в последовательную цепочку.

const xhr = new XMLHttpRequest();

xhr.addEventListener('load', () => {
  console.log(xhr.status, xhr.statusText);
});

xhr.open('GET', 'https://26.javascript.pages.academy/code-and-magick/data');

xhr.send();

//
fetch(
    'https://26.javascript.pages.academy/code-and-magick',
    {
      method: 'POST',
      credentials: 'same-origin',
      body: new FormData(),
    },
  )
    .then((response) => {
      console.log(response.status);
      console.log(response.ok);
      return response.json();
    })
    .then((data) => {
      console.log('Результат', data);
    });
//
// load.js  
const createLoader = (onSuccess, onError) => () => {
    return fetch(
      'https://26.javascript.pages.academy/code-and-magick/data',
      {
        method: 'GET',
        credentials: 'same-origin',
      },
    )
      .then((response) => {
        if (response.ok) {
          return response.json();
        }
  
        throw new Error(`${response.status} ${response.statusText}`);
      })
      .then((data) => {
        onSuccess(data);
      })
      .catch((err) => {
        onError(err);
      });
  };
  
  export {createLoader};
//main.js
import {createLoader} from './load.js';

const loadAnimals = createLoader(console.log, console.error);

loadAnimals();
