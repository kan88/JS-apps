// // Клонирование и вставка элементов. 2 часть
// // Мы вставили шаблон, после него другой элемент и снова попробовали вставить шаблон.
//  В итоге шаблон оказался только один и в конце списка. Почему так произошло?

// // Потому что элемент только один, даже если это шаблон. Мы не можем вставить один 
// элемент несколько раз в разные места страницы. Мы же не можем быть в нескольких местах одновременно? Вот и элементы DOM не могут.

// // Поэтому существует клонирование DOM-элементов. Мы можем клонировать любые элементы,
//  в том числе шаблоны, и вставлять эти копии на страницу сколько угодно раз.

// // Для начала разберёмся, как работает клонирование. Для этого нужно использовать метод 
// cloneNode. Он возвращает склонированный элемент.

// // Обратите внимание, у этого метода есть аргумент — булево значение. Если передать значение
//  false, то будет скопирован сам элемент со своими классами и атрибутами, но без дочерних 
//  элементов.
// Если при передаче false в cloneNode копируется элемент без вложенностей, то при передаче 
// true всё наоборот. В таком случае клонируется сам элемент вместе со всеми вложенностями. 
// Причём клонируются атрибуты, классы и текстовое содержимое всех вложенностей. Такое 
// клонирование называется глубоким.

// Раньше метод cloneNode вёл так себя по умолчанию, даже без передачи true. В новом стандарте 
// это изменилось и без аргумента метод должен делать неглубокое копирование, как если бы был 
// передан false. Но стандарт фиксирует рекомендации, а браузеры решают следовать им или нет. 
// Сейчас не все браузеры перешли на новый стандарт и для обратной совместимости сохраняют 
// старое поведение, когда по умолчанию клонирование было глубоким.

// Поэтому лучше всегда передавать булево значение, чтобы избежать непредсказуемого поведения 
// в программах.

// element.cloneNode(true);  // Вернёт склонированный элемент со всеми вложенностями
// element.cloneNode();      // 0_o