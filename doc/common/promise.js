// Promise (промис)
// Промис — это глобальный объект Promise. Он позволяет отследить выполнение асинхронной операции и сохранить её результат. Сами асинхронные операции выполняются как и прежде: не сразу, а когда-нибудь. Поэтому важно запомнить и уяснить, промисы — это не «магическая» замена асинхронных операций и не возможность получить результат такой операции сразу. Это просто объект, позволяющий более эффективно работать с асинхронным кодом.

// Синтаксис
// Чтобы воспользоваться промисами, необходимо создать экземпляр объекта Promise с помощью new:

// const myPromise = new Promise((resolve, reject) => {});
// Аргументом в new Promise() нужно передать функцию. Её принято называть «функция-исполнитель» (от англ. executor). У этой функции два параметра-колбэка:

// resolve — колбэк, который нужно вызвать, если промис завершён успешно;
// reject — колбэк, который нужно вызвать, если промис завершён с ошибкой.
// Например:

const myPromise = new Promise((resolve, reject) => {
  if (2 > 1) {
    // Если всё верно, вызываем resolve, и тем самым объявляем, что myPromise завершён успешно
    resolve();
  } else {
    // Если в какой-то вселенной 2 не больше 1, вызываем reject, и тем самым объявляем, что myPromise завершён с ошибкой
    reject();
  }
});
// Что значит «завершён», и о других состояниях промиса мы поговорим в конце главы.

// Важно уточнить, что функцию-исполнителя браузер выполнит сразу. Это может быть неочевидно на первый взгляд. Для примера запустите в консоли код:

const myPromise = new Promise(() => {
  console.log('Привет! Я функция-исполнитель.');
});
// После выполнения в консоль сразу же выведется 'Привет! Я функция-исполнитель.'
const porridge = new Promise((resolve, reject) => {
    multicooker.addEventListener('done', () => {
      resolve('Овсянка, сэр.');
    });
    multicooker.addEventListener('error', () => {
      reject('Каши не будет, электричество кончилось.');
    });
  });

//   Если нам нужно вернуть значение, его нужно передать аргументом resolve или reject.

// Функцию-исполнитель браузер выполнит сразу, и мультиварке multicooker добавятся два обработчика событий. Затем выполнение перейдёт к другому коду программы. Колбэки же resolve или reject будут вызваны лишь тогда, когда у мультиварки наступят соответствующие события. Вот она, асинхронность.

// Результат
// Всё складно, кроме одного. Если выполнение после создания промиса переходит к другому коду программы, как нам получить результат, который будет передан, например, в resolve? Для этого у каждого созданного промиса есть метод then():

const porridge = new Promise((resolve, reject) => {
    multicooker.addEventListener('done', () => {
      resolve('Овсянка, сэр.');
    });
    multicooker.addEventListener('error', () => {
      reject('Каши не будет, электричество кончилось.');
    });
  });
  
  +// В then первым аргументом мы передаём функцию,
  +// которая станет тем самым колбэком resolve
  +porridge.then((message) => {
  +  console.log(message); // 'Овсянка, сэр.'
  +});
// 
Состояние промиса
Мы уже с вами затрагивали состояние завершённости промиса, давайте разберёмся во всех возможных состояниях промисов.

Как только мы объявляем промис, он попадает в состояние pending, что означает выполняется:

const myPromise = new Promise(() => {});
Затем, когда и если будут вызваны колбэки resolve или reject, промис перейдёт в состояние settled, что означает завершён:

const myPromise = new Promise((resolve, reject) => {
  if (2 > 1) {
    resolve();
  } else {
    reject();
  }
});
// 

цепочки промисов

Прежде, чем перейти к цепочкам промисов, разберёмся до конца с методами промисов. Вы уже знаете, что существует метод then() и чтобы получить результат завершённого промиса, нужно передать в него две функции, которые впоследствии станут колбэками resolve и reject:

const myPromise = new Promise((resolve, reject) => {});

myPromise.then(
  () => {}, // Станет resolve
  () => {}, // Станет reject
);
Однако для передачи функции, которая станет колбэком reject, есть другой способ.

Метод catch()
Второй способ обработки перехода промиса в состояние завершён с ошибкой заключается в использовании метода catch(). Аргументом ему необходимо передать колбэк для reject:

const myPromise = new Promise((resolve, reject) => {});

myPromise.then(() => {});
myPromise.catch(() => {});
Однако так почти никто не пишет, поскольку в промисах можно использовать цепочки вызовов методов:

const myPromise = new Promise((resolve, reject) => {});

myPromise.then(() => {}).catch(() => {});
Работает это так: первым мы вызываем then() у myPromise, вызов которого тоже возвращает промис, поэтому мы можем снова вызвать метод промиса catch(). Причём вызывать именно catch() не обязательно, можно снова then(), например:

const myPromise = new Promise((resolve, reject) => {});

myPromise.then(() => {}).then(() => {}).then(() => {}).catch(() => {});
Это и есть «цепочки промисов», но о них в конце главы.

Метод finally()
Кроме then() и catch() существует метод finally(). На случай, когда нужно выполнить функцию вне зависимости от того, завершился промис успешно или с ошибкой. Другими словами finally() позволяет не дублировать один и тот же код в then() и catch():

const myPromise = new Promise((resolve, reject) => {});

myPromise
  .then(() => {
    console.log('Промис завершён успешно :-)');
    console.log('Спасибо за внимание');
  })
  .catch(() => {
    console.log('Промис завершён с ошибкой :-(');
    console.log('Спасибо за внимание');
  });
const myPromise = new Promise((resolve, reject) => {});

myPromise
  .then(() => {
    console.log('Промис завершён успешно :-)');
-    console.log('Спасибо за внимание');
  })
  .catch(() => {
    console.log('Промис завершён с ошибкой :-(');
-    console.log('Спасибо за внимание');
  })
+  .finally(() => {
+    console.log('Спасибо за внимание');
+  });
// Цепочки промисов
// Синтаксис
// Мы рассмотрели общий принцип работы с промисами и теперь готовы познакомиться с важной возможностью промисов: построением цепочек. Начнём с основ. Ранее мы вскользь проговорили, что метод then() возвращает промис. Так вот, методы then(), catch() и finally() всегда возвращают новый промис. За счёт этого мы можем строить цепочки вызовов методов промисов. Собственно это мы и сделали, когда использовали метод catch() и finally(). Всё благодаря тому, что сперва then() вернул новый промис, а потом catch().

// А зачем нам может пригодиться эта возможность? Для последовательного выполнения операций! Давайте детально разберём наш пример про кашу на завтрак. Что скрывается за словами «приготовить кашу»? Даже с нашей чудо-мультиваркой это несколько последовательных асинхронных действий: насыпать крупу, залить молоком, добавить масло, запустить программу. Вот тут нам и пригождаются цепочки:

const breakfast = new Promise();

// Для простоты примера просто представим,
// что все функции, переданные в then, объявлены ранее

breakfast
  .then(getOatmeal) // Находим крупу
  .then(getMilk) // Находим молоко
  .then(getButter) // Находим масло
  .then(shakeProducts) // Смешиваем всё в мультиварке
  .then(startMulticookerProgram) // Запускаем программу мультиварки
  .then(() => {}) // Последний then на случай успеха
  .catch(() => {}); // catch на случай ошибки в любом месте
// Глядя на этот код, мы можем легко определить последовательность действий. Давайте вместе проговорим, как выполняется приведённый фрагмент кода: первый then() вернёт новый промис. Затем мы снова вызываем then() и определяем колбэк для resolve уже этого нового промиса. После мы повторяем этот алгоритм для всех остальных then() и, на случай ошибки где-то в цепочке, определяем колбэк для catch().

// Обратите внимание на применение метода catch(). Мы описываем его один раз в конце цепочки промисов. Как в этом случае будет происходить обработка ошибки? Если любой из вышестоящих промисов в цепочке будет завершён с ошибкой, то мы попадём в catch() и сможем обработать эту ситуацию. Стоит отметить, что выполнение цепочки на этом прекратится. Если ошибка произошла в первом then(), то последующие then() выполняться не будут, инициативу перехватит catch().

// Результат предыдущего промиса в цепочке
// При построении цепочек из промисов мы получаем ещё одну крутую возможность — передачу результата выполнения промиса вниз по цепочке. Это означает, что в каждом последующем then() мы можем получить результат выполнения колбэка предыдущего then(). Посмотрим на примере:

// Объявляем промис sum и сразу успешно его завершаем с результатом 1
const sum = new Promise((resolve) => resolve(1));

sum
  .then((result) => result + 1) // Затем результат попадёт в then, где увеличивается на единицу и передаётся дальше
  .then((result) => result + 1) // И снова +1
  .then((result) => console.log(result)); // В итоге: 1 + 1 + 1 = 3
// Каждый колбэк, который мы описываем для then(), возвращает результат увеличения значения, полученного в виде параметра на единицу. Этот результат передаётся вниз по цепочке. Таким образом, в конце мы получаем 3. Эту возможность можно сравнить с конвейерной лентой. На каждом шаге появляется возможность улучшить предыдущий результат.

// Цепочки промисов на практике
// Наверняка вас интересует вопрос применения цепочек из промисов на практике. Подход применяется довольно часто. Возьмём задачу получения данных от сервера. Сначала мы должны получить данные (например, в виде JSON строки), затем их десериализовать (прочитать), потом, возможно, нужно что-то в них добавить или удалить, и так далее. Это прекрасная задачка для применения цепочек.

// Резюме
// Методы then(), catch() и finally() всегда возвращают новый промис. За счёт этого появляется возможность строить цепочки вызовов промисов.