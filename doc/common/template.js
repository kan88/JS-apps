// // У нас есть данные, чтобы создать новую задачу. Мы знаем, в какой момент можно добавить задачу на страницу. Осталось разобраться, как именно будет реализовано добавление нового элемента.

// // Мы уже создавали новые элементы через createElement, но этот способ долгий. Сначала надо создать элемент, задать ему класс, атрибуты, потом так же создать дочерние элементы, вложить их в родителя и потом отрисовать на страницу.

// // Было бы удобно, если бы вся необходимая разметка для будущих элементов уже где-то хранилась. Нам бы оставалось только подправить содержимое под каждый элемент. И это можно сделать с помощью тега template.

// // Он хранит в себе шаблон для будущих элементов. Тег template находится там же, где и вся разметка сайта, только его содержимое не отображается на странице. В нашей разметке тоже есть template. Он хранит шаблонную разметку новой задачи.

// // Чтобы получить template в JavaScript, его можно найти по названию тега, например, через querySelector('template'). У этого способа есть минус — шаблонов на странице может быть много. Обычно каждому тегу template дают уникальное название и записывают в атрибут id (идентификатор). Значения этого атрибута не могут повторяться на одной странице. По id можно найти необходимый шаблон.

// // Шаблон в разметке:

// // <body>
// //   …
// //   <template id="text-template">
// //       <p class="text"></p>
// //   </template>
// // </body>
// // Поиск элемента в JavaScript:

// // document.querySelector('#text-template');
// // Решётка в параметре querySelector обозначает, что искать надо по id.

// // У нашего шаблона идентификатор task-template. Найдём этот template и выведем содержимое тега на страницу.

// // Есть ещё один метод в DOM API, который позволяет искать элементы по идентификатору — getElementById. В отличие от других методов он может быть вызван только на всём документе, а не отдельном элементе. Мы познакомимся с этим методом ближе в других тренажёрах, пока потренируемся искать элементы по id с помощью querySelector. Если вам хочется узнать подробности о новом методе поскорей, можете почитать про него на MDN.

// Контент тега <template>, document-fragment
// Если вы развернёте taskTemplate в консоли, вы увидите, что внутри него есть некий document-fragment, а уже внутри него тот самый шаблон, который нам нужен.

// Что это за document-fragment и как из него достать наш шаблон?

// document-fragment или просто фрагмент является хранилищем содержимого тега template. Именно благодаря ему разметка из template не отображается на странице. Вы можете в этом убедиться, если добавите самому тегу стили: например, явную ширину и высоту и яркий фоновый цвет. Тогда вы увидите элемент template на странице, но его содержимое нет.

// Если искать элементы через querySelector и другие методы поиска внутри template, то мы не получим нужные нам элементы. Они лежат в свойстве content этого тега. Это свойство и содержит document-fragment, внутри которого уже можно искать привычными методами поиска.

// <body>
//   …
//   <template id="text-template">
//     <p class="text"></p>
//   </template>
// </body>
// Если мы хотим найти элемент в шаблоне, надо искать так:

// var template = document.querySelector('#text-template');
// // Нашли template в документе

// var content = template.content;
// // Получили содержимое, фрагмент

// var text = content.querySelector('.text');
// // Нашли нужный шаблон
// Эту запись можно сократить. Например, записать в отдельную переменную контент, а в другую искомый шаблон.

// var textTemplate = document.querySelector('#text-template').content;
// var text = textTemplate.querySelector('.text');
// Такая запись удобней, потому что отдельно в коде элемент template обычно не используют. Вся работа ведётся с его контентом и шаблоном, который в этом контенте хранится.

// В шаблоне можно менять текст, классы, а затем добавлять элементы на страницу. Это мы сделаем в следующих шагах. А пока найдём content и внутри него элемент с классом item, который является шаблоном новой задачи.

const pools = document.querySelectorAll('.pool');

const templateFragment = document.querySelector('#element-template').content; // Находим фрагмент с содержимым темплейта

const template = templateFragment.querySelector('div'); // В фрагменте находим нужный элемент

const fragment = document.createDocumentFragment();

for (let i = 0; i < 6; i++) {
  const element = template.cloneNode(true); // Клонируем элемент со всеми "внутренностями"
  element.classList.add('el-' + (i + 1)); // Добавляем порядковый класс, который начинается с единицы, а не с нуля, поэтому 'i + 1'
  element.children[0].textContent = i; // Записываем содержимое
  fragment.appendChild(element);
}

pools[1].appendChild(fragment);