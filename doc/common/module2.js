Модуль должен описывать и давать понимание, какие у него есть зависимости. 
Например, модуль может зависеть от других модулей.

// Файл сain.js
import {name} from './mother.js';

`My mother is ${name}`; // My mother is Eve
Модуль сain.js зависит от модуля mother.js, а конкретно от переменной name,
 полученной из этого модуля.

Про синтаксис import и export сейчас нужно знать лишь то, что они есть, 
что import — это импорт, а export — экспорт в прямых своих значениях. О всех остальных нюансах мы поговорим далее.

Модуль должен описывать интерфейс — методы и свойства — которые он может предоставить другим модулям. Чтобы предыдущий пример работал, нам нужно показать, что у модуля mother.js в интерфейсе есть свойство name, которое могут использовать другие модули.

// Файл mother.js
const name = 'Eve';

export {name};

// Файл mother.js
const motherName = 'Eve';

export {motherName};
// Файл father.js
const fatherName = 'Adam';

export {fatherName};
// Файл сain.js
import {motherName} from './mother.js';
import {fatherName} from './father.js';

`My mother is ${motherName}`; // My mother is Eve
`My father is ${fatherName}`; // My father is Adam
Чтобы браузер считал JS-файл модулем, его нужно подключить как модуль:

<script type="module" src="сain.js"></script>

В противном случае модульные конструкции вроде import и export ничего кроме ошибки не вызовут.

Просто импорт
Когда нам нужно только выполнить код модуля, достаточно его просто импортировать:

// Файл alert.js
alert('Hello, world!');
// Файл index.js
import './alert.js';

Именованные экспорт и импорт
Обратите внимание, экспорт и импорт похожи на деструктуризацию, но только похожи.

Всё просто, в одном модуле мы явно говорим, что хотим экспортировать:

// Файл mother.js
const name = 'Eve';
const age = 18;

export const sex = 'female'; // Экспорт сразу при объявлении

export {name, age}; // Экспорт уже объявленных переменных
А в другом явно это импортируем:

// Файл сain.js
import {name} from './mother.js';

`My mother is ${name}`; // My mother is Eve
Имена переменных должны совпадать полностью. Если запрашиваемой переменной нет среди экспортируемых, то будет ошибка, и модуль не загрузится. Импортировать всё, что экспортирует модуль, необязательно, поэтому мы ограничились только переменной name, а могли бы импортировать всё:

import {sex, name, age} from './mother.js';
Экспортировать одну и ту же переменную дважды нельзя:

// Файл mother.js
const name = `Eve`;
const age = 18;

export const sex = `female`;

export {sex};

Импорт — не объявление
Важно помнить, что импорт переменной не то же самое, что её объявление. При импорте переменная не создаётся, а честно импортируется, самая настоящая переменная из другого модуля. Такое поведение справедливо для всех видов импорта, которые мы разберём дальше (экспортировать как-то иначе тоже нельзя), поэтому будьте внимательны при работе с импортированными переменными. Ведь сложные типы данных, вроде объектов или массивов, при импорте передаются по ссылке, и их можно нечаянно испортить:

// Файл items.js
const items = ['one', 'two', 'three'];

export {items};
// Файл reverse.js
import {items} from './items.js';

items.reverse(); // Испортили массив в модуле items.js, хотя переворачиваем его в reverse.js

Поэтому не забывайте про Object.assign() и Array.prototype.slice() и им подобные методы, когда работаете с импортированной структурой:

// Файл items.js
const items = ['one', 'two', 'three'];

export {items};
// Файл reverse.js
import {items} from './items.js';

items.slice().reverse(); // Перевернули копию, исходный массив в items.js остался цел

С примитивами тоже не всё так просто. Даже если импортируете let-переменную, по спецификации движок JavaScript не позволит вам изменить её. Она считается read-only переменной (доступной только для чтения):

// Файл mother.js
let name = 'Eve';

export {name};
// Файл сain.js
import {name} from './mother.js';

name = 'Adam'; // Ничего не выйдет, кроме ошибки
Поэтому распространённой практикой является экспорт только const-значений и им подобных (классов, например). На курсе мы тоже будем экспортировать только const-переменные или class.

Экспорт по умолчанию
Синтаксически экспорт по умолчанию отличается вводом дополнительного ключевого слова default:

// Файл mother.js
const mother = {
  name: 'Eve',
  age: 18,
  sex: 'female',
};

export default mother;
Фигурные скобки не нужны, поскольку экспортировать по умолчанию можно лишь одну переменную.

Главное отличие такого экспорта от именованного — возможность экспортировать значение напрямую, без переменной:

// Файл mother.js
export default {
  name: 'Eve',
  age: 18,
  sex: 'female',
};
Из-за этого отличается и импорт такого значения «по умолчанию». Раз у нас нет переменной, то под каким именем импортировать? Под любым!

import father from './mother.js';
В этом заключается и главная особенность, и главная проблема экспорта по умолчанию — мы можем задать любое имя при импорте. Такое поведение усложняет отладку и навигацию по коду, поэтому мы не рекомендуем использовать экспорт по умолчанию.

Нюансы
Код модуля выполняется целиком
Независимо от того, импортирован ли просто модуль import './alert.js' или какие-то конкретные переменные из модуля import {name} from './mother.js', браузер выполнит код всего модуля. Другими словами, если модуль импортирован, его код будет выполнен целиком независимо от способа импорта.

Только первый уровень
import и export не могут быть вложены в функции или другие блоки кода:

// Файл сain.js
if (true) {
  // Так нельзя
  import {motherName} from './mother.js';
}

const name = `сain`;

(() => {
  // Так тоже нельзя
  export { name };
})();


Никакого поднятия (hoisting)
Импортированные переменные не поднимаются, поэтому import всегда должен быть в начале файла:

const message = `My mother is ${motherName}`;

// Так нельзя, браузер выдаст ошибку
import {motherName} from './mother.js';